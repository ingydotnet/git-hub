#!/usr/bin/env perl

use strict;

sub main {
    my ($cmd) = @_;
    my $input = do { local $/; <> };
    my $input2 = do { local $/; <> };
    my ($options_spec) = $input2 =~ m/ ^ OPTIONS_SPEC="\\ $ (.*?) ^ " $/xsm;
    $options_spec =~ s/.*Options:\n--//s;

    my %functions;
    my @options;
    for my $line (split m/\n/, $options_spec) {
        next unless $line =~ m/\S/;
        my $arg = 0;
        my ($key, $desc) = split ' ', $line, 2;
        if ($key =~ s/=$//) {
            $arg = 1;
        }
        my @keys = split m/,/, $key;
        my $function_name;
        if ($key eq "remote") {
            $function_name = "_git-hub-complete-remote";
            my $function = {
                name => $function_name,
                command => "git remote",
            };
            $functions{ $key } = $function;
        }
        push @options, {
            keys => \@keys,
            arg => $arg,
            desc => $desc,
            function_name => $function_name,
        };
    }

    $input =~ s/.*?\n= Commands\n//s;
    $input =~ s/(.*?\n== Configuration Commands\n.*?\n)==? .*/$1/s;
    my @list;
    my @repo_cmds;
    while ($input =~ s/.*?^- (.*?)(?=\n- |\n== |\z)//ms) {
        my $text = $1;
        $text =~ /\A(.*)\n/
            or die "Bad text '$text'";
        my $usage = $1;
        $usage =~ s/\A`(.*)`\z/$1/
            or die "Bad usage: '$text'";
        (my $name = $usage) =~ s/ .*//;
        push @list, $name;
        if ($usage =~ m#\Q$name\E \(?\[?(<owner>/)?\]?<repo>#) {
            push @repo_cmds, $name;
        }
    }
    @repo_cmds = sort @repo_cmds;
    @list = sort @list;

    if ($cmd eq "bash") {
        generate_bash(\@list, \@repo_cmds, \@options, \%functions);
    }
    else {
        generate_zsh(\@list, \@repo_cmds, \@options, \%functions);
    }
}

sub generate_zsh {
    my ($list, $repo_cmds, $options, $functions) = @_;

    my $options_string = '';
    for my $opt (@$options) {
        my $keys = $opt->{keys};
        my $desc = $opt->{desc};
        my $function = $opt->{function_name};
        $desc =~ s/'/'"'"'/g;
        # examples:
        #'(-c --count)'{-c,--count}'[Number of list items to show]:count' \
        #'--remote[Remote name (like "origin")]:remote' \
        my $arg = '';
        if ($opt->{arg}) {
            $arg = ":$keys->[0]";
        }
        else {
            $arg .= ":";
        }
        if ($function) {
            $arg .= ":$function";
        }
        my @keystrings = map { (length $_ > 1 ? "--" : "-") . $_ } @$keys;
        if (@$keys == 1) {
            $options_string .= sprintf "        '%s[%s]%s' \\\n",
                $keystrings[0], $desc, $arg;
        }
        elsif (@$keys > 1) {
            $options_string .= sprintf "        '(%s)'{%s}'[%s]%s' \\\n",
                (join ' ', @keystrings), (join ',', @keystrings), $desc, $arg;
        }
    }

    my $function_list = '';
    for my $key (sort keys %$functions) {
        my $function = $functions->{ $key };
        my $name = $function->{name};
        my $cmd = $function->{command};
        my $body = <<"...";
$name() {
    local dynamic_comp
    IFS=\$'\\n' set -A  dynamic_comp `$cmd`
    compadd -X "$key:" \$dynamic_comp
}
...
        $function_list .= "$body\n";
    }

    print <<'...';
#compdef git-hub -P git\ ##hub
#description perform GitHub operations

# DO NOT EDIT. This file generated by tool/generate-completion.pl.

if [[ -z $GIT_HUB_ROOT ]]; then
	echo 'GIT_HUB_ROOT is null; has `/path/to/git-hub/.rc` been sourced?'
	return 3
fi

_git-hub() {
    typeset -A opt_args
    local curcontext="$curcontext" state line context

    local update_policy
    zstyle -s ":completion:$curcontext:" cache-policy update_policy
    if [[ -z "$update_policy" ]]; then
        zstyle ":completion:$curcontext:" cache-policy _git_hub_caching_policy
    fi

    _arguments -s \
        '1: :->subcmd' \
        '2: :->repo' \
...
    print $options_string;
    print <<'...';
        && ret=0

    case $state in
    subcmd)
...
    print <<"...";
        compadd @$list
    ;;
    repo)
        case \$line[1] in
...
    print " " x 8;
    print join '|', @$repo_cmds;
    print <<"...";
)
            [[ "\$line[2]" =~ ^- ]] && return;
            local repo_to_complete="\$line[2]"
            if [[ "\$repo_to_complete" =~ "^\@/?\$" || \\
                "\$repo_to_complete" =~ "^\@/(.*)" || \\
                "\$repo_to_complete" =~ "^/?([a-z0-9_-]*)\$" ]];
            then
                local login=`git hub config login`
                compadd -U -S '' "\$login/\$match[1]"
                return
            elif [[ "\$repo_to_complete" =~ "^\@.+/" ]]; then
                repo_to_complete="\${repo_to_complete/\\\@}"
                compadd -U -S '' "\$repo_to_complete"
                return
            fi

            if [[ "\$repo_to_complete" =~ "^\@([a-z0-9_][a-z0-9_-]*)\$" ]];
            then
                local users
                local username="\$match[1]"

                if [[ "\$#username" -lt 2 ]]; then
                    compadd -x "Users (type at least two characters)"
                    return
                fi

                local _git_hub_cached_users
                local cache_key="git-hub-search-user-\$username"
                if _cache_invalid \$cache_key || ! _retrieve_cache \$cache_key ; then
                    users=( \$( git hub search-user "\$username in:login" --raw --count 100 | tr '[:upper:]' '[:lower:]' | sed -e 's/^/\@/' ) )
                    _git_hub_cached_users=("\${users[\@]}")
                    _store_cache \$cache_key _git_hub_cached_users
                else
                    users=("\${_git_hub_cached_users[\@]}")
                fi

                if [[ \${#users[\@]} -eq 1 ]]; then
                    local user="\$users[1]"
                    user="\${user/\\\@/}"
                    compadd -S / -U -X "Users:" "\$user"
                else
                    compadd -U -X "Users:" \$users
                fi

            else
                local username reponame
                if [[ "\$repo_to_complete" =~ "^([a-z0-9_][a-z0-9_-]+)/([a-zA-Z0-9_.-]*)" ]];
                then
                    local username="\$match[1]"
                    local reponame="\$match[2]"
                else
                    # git hub repo foobar<TAB>
                    username=`git hub config login`
                    reponame="\$repo_to_complete"
                fi
                local reponames

                local _git_hub_cached_repos
                local cache_key="git-hub-search-repo-\$username/repo-\$reponame"
                if _cache_invalid \$cache_key || ! _retrieve_cache \$cache_key ; then
                    IFS=\$'\\n' set -A reponames `git hub search-repo "\$reponame user:\$username in:name fork:true" --raw --count 100`
                    _git_hub_cached_repos=("\${reponames[\@]}")
                    _store_cache \$cache_key _git_hub_cached_repos
                else
                    reponames=("\${_git_hub_cached_repos[\@]}")
                fi

                compadd -X "Repos:" \$reponames
            fi
        ;;

        config|config-unset)
            local config_keys
            IFS=\$'\\n' set -A config_keys `git hub config-keys`
            compadd -X "Config keys:" \$config_keys
        ;;
        help)
            compadd @$list
        ;;
        esac
    ;;
    esac

}

$function_list
_git_hub_caching_policy() {
    local -a oldp
    # older than 20 minutes
    oldp=( "\$1"(mm+20) )
    (( \$#oldp )) && return 0
    return 1
}

...
}

sub generate_bash {
    my ($list, $repo_cmds, $options, $functions) = @_;

    my $options_string = '';
    for my $opt (@$options) {
        my $keys = $opt->{keys};
        my $arg = '';
        if ($opt->{arg}) {
            $arg = "=";
        }
        my @keystrings = map { (length $_ > 1 ? "--" : "-") . $_ } @$keys;
        for my $key (@keystrings) {
            $options_string .= " $key$arg";
        }
    }

    my @function_list;
    for my $key (sort keys %$functions) {
        my $function = $functions->{ $key };
        my $name = $function->{name};
        my $cmd = $function->{command};
        my $body = <<"...";
[[ \$last == "--$key" || \$cur =~ ^--$key= ]]; then
            local dynamic_comp=`$cmd`
            __gitcomp "\$dynamic_comp" "" "\${cur##--$key=}"
            return
...
        push @function_list, $body;
    }
    my $indent = " " x 8;
    my $function_list = "${indent}if "
        . join ("\n${indent}elsif ", @function_list)
        . "${indent}fi";

    print <<"...";
#!bash

# DO NOT EDIT. This file generated by tool/generate-completion.pl.

_git_hub() {
    local _opts="$options_string"
    local subcommands="@$list"
    local repocommands="@$repo_cmds"
    local subcommand="\$(__git_find_on_cmdline "\$subcommands")"

    if [ -z "\$subcommand" ]; then
        # no subcommand yet
        case "\$cur" in
        -*)
            __gitcomp "\$_opts"
        ;;
        *)
            __gitcomp "\$subcommands"
        esac

    else

        # dynamic completions
        local last=\${COMP_WORDS[ \$COMP_CWORD-1 ]}

$function_list

        case "\$cur" in

        -*)
            __gitcomp "\$_opts"
            return
        ;;
        esac

        if [[ \$subcommand == help ]]; then
            __gitcomp "\$subcommands"
            return
        elif [[ \$subcommand == "config" || \$subcommand == "config-unset" ]]; then
            local config_keys
            config_keys=`git hub config-keys`
            __gitcomp "\$config_keys"
            return
        fi

        local repocommand="\$(__git_find_on_cmdline "\$repocommands")"
        if [ -n "\$repocommand" ]; then

            local repo_to_complete="\$cur"
            if [[ "\$repo_to_complete" == "" || "\$repo_to_complete" == "\@" ]]; then
                local login=`git hub config login`
                COMPREPLY=("\$login/")
                return
            elif [[ "\$repo_to_complete" =~ ^\@/ || "\$repo_to_complete" =~ ^/ ]]; then
                local login=`git hub config login`
                repo_to_complete="\${repo_to_complete/\\\@}"
                repo_to_complete="\$login""\$repo_to_complete"
            elif [[ "\$repo_to_complete" =~ ^\@.+/ ]]; then
                repo_to_complete="\${repo_to_complete/\\\@}"
            elif [[ "\$repo_to_complete" =~ ^([a-zA-Z0-9_-]+)\$ ]]; then
                local login=`git hub config login`
                repo_to_complete="\$login/\$repo_to_complete"
            fi

            # note: username completion works only for lowercase at the
            # moment. usernames with uppercase letters will be lowercased
            if [[ "\$repo_to_complete" =~ ^@([a-z0-9_][a-z0-9_-]+) ]];
            then
                # git hub repo \@foo<TAB>
                local username="\${BASH_REMATCH[1]}"
                # first, check the cache
                local cached
                __git_hub_try_cache "user" "\$username"
                local users=("\${cached[\@]}")
                if [[ -z "\$cached" ]]; then
                    # nothing in cache
                    # echo \$'\\n'"Completing usernames..."
                    users=( \$(git hub search-user "\$username in:login" --raw --count 100 | tr '[:upper:]' '[:lower:]' | sed -e 's/^/\@/' ) )
                fi
                local comp="\${users[\@]}"
                COMPREPLY=( \$( compgen -W "\$comp" -- "\@\$username" ) )
                local count=\${#COMPREPLY[\@]}
                if [[ \$count -eq 1 ]]; then
                    local user="\${COMPREPLY[0]}"
                    user="\${user/\\\@/}"
                    COMPREPLY=("\$user/")
                fi
                if [[ -z "\$cached" ]]; then
                    __git_hub_save_user_cache "\$username"
                fi

            else
                local username reponame
                if [[ "\$repo_to_complete" =~ ^([a-zA-Z0-9_-]+)/(.*) ]];
                then
                    # git hub repo foobar/<TAB>
                    username="\${BASH_REMATCH[1]}"
                    reponame="\${BASH_REMATCH[2]}"
                else
                    # git hub repo foobar<TAB>
                    username=`git hub config login`
                    reponame="\$repo_to_complete"
                fi

                # first, check the cache
                local cached
                __git_hub_try_cache "repo" "\$username/\$reponame"
                local reponames=("\${cached[\@]}")
                if [[ -z "\$cached" ]]; then
                    # nothing in cache
                    # echo \$'\\n'"Completing reponames..."
                    reponames=( \$( git hub search-repo "\$reponame user:\$username in:name fork:true" --raw --count 100 ) )
                    __git_hub_save_repo_cache "\$username/\$reponame"
                fi
                local comp="\${reponames[\@]}"
                COMPREPLY=( \$( compgen -W "\$comp" -- "\$username/\$reponame" ) )

            fi

        fi

    fi
}

__git_hub_save_repo_cache() {
    __git_hub_last_repo="\$1"
    __git_hub_last_repo_result=("\${reponames[@]}")
}

__git_hub_save_user_cache() {
    __git_hub_last_user="\$1"
    __git_hub_last_user_result=("\${users[@]}")
}

__git_hub_try_cache() {
    local cachetype="\$1"
    local name="\$2"
    local last="__git_hub_last_\$cachetype"
    local last_result="__git_hub_last_\${cachetype}_result"
    # if we got 100 results that means that there were probably more, so the
    # result is incomplete. We only return this cached result if the
    # key equals the cache key from last time.
    local key="\${!last}"
    local result
    if [[ \$cachetype == user ]]; then
        result=("\${__git_hub_last_user_result[@]}")
    elif [[ \$cachetype == repo ]]; then
        result=("\${__git_hub_last_repo_result[@]}")
    fi
    if [[ "\$key" == "\$name" \\
        || ( "\${name:0:\${#key}}" == "\$key" \\
        && \${#result[@]} -lt 100 \\
        ) ]]; then
        cached=("\${result[@]}")
    fi
}
...
}

main(shift);
